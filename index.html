<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <title>nano-mania</title>
    <link rel="stylesheet" href="./style.css" />
  </head>
  <body>
    <!-- interraction -->
    <style>
      #shelf-interaction {
        display: none;
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        background-color: rgb(98, 99, 100);
        color: white;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        font-size: 20px;
        list-style-type: none; /* Enlever les puces */
        overflow-y: auto;
        max-height: 200px;
        box-sizing: border-box;
        margin-top: 10px;
      }
      #inventory {
        position: fixed;
        right: 10px; /* Positionnez à gauche */
        top: 50%; /* Centrez verticalement */
        transform: translateY(-50%); /* Ajustez pour centrer */
        background-color: rgba(255, 255, 255, 0.8); /* Fond semi-transparent */
        padding: 10px;
        border-radius: 10px;
        display: none; /* Masqué par défaut */
        list-style: none;
      }
      .card {
        position: fixed; /* Position fixe pour rester en bas à gauche */
        bottom: 20px; /* Distance du bas de l'écran */
        left: 20px; /* Distance du côté gauche de l'écran */
        width: 80px; /* Largeur de la carte */
        height: 80px; /* Hauteur de la carte */
        border-radius: 10px; /* Coins arrondis */
        background-color: rgba(
          255,
          255,
          255,
          0.8
        ); /* Fond blanc avec transparence */
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Ombre */
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition: transform 0.2s;
        z-index: 10; /* Assurez-vous que la carte est au-dessus de la scène */
      }

      .card:hover {
        transform: scale(1.05); /* Effet de zoom au survol */
      }

      .inv {
        width: 50px;
        height: 50px;
      }
      .inventory {
        list-style-type: none;
        padding: 0;
        background-color: rgba(255, 255, 255, 0.8);
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 10px;
        position: fixed;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        display: none; /* Masqué par défaut */
      }
        #money {
    position: fixed;
    top: 10px;
    right: 10px;
    font-size: 24px;
    font-weight: bold;
    background: #222;
    color: #fff;
    padding: 10px 15px;
    border-radius: 8px;
  }
  #cash-register {
    position: fixed;
    bottom: 50px;
    left: 50%;
    transform: translateX(-50%);
    width: 120px;
    height: 100px;
    background: #444;
    border-radius: 12px;
    text-align: center;
    line-height: 100px;
    color: white;
    font-weight: bold;
    font-size: 18px;
  }
  .pnj {
    position: absolute;
    width: 40px;
    height: 60px;
    background: #3498db;
    border-radius: 10px;
    text-align: center;
    color: white;
    font-weight: bold;
    line-height: 60px;
    user-select: none;
  }
  #shelf {
    position: fixed;
    top: 50%;
    left: 20px;
    transform: translateY(-50%);
    width: 100px;
    height: 300px;
    background: #8B4513;
    border-radius: 10px;
    padding: 10px;
    color: white;
  }
  #shelf div.item {
    background: #f39c12;
    margin: 5px 0;
    padding: 5px;
    border-radius: 5px;
    cursor: default;
    user-select: none;
    text-align: center;
  }
    </style>
    <div
      id="money"
      style="
        position: fixed;
        left: 10px;
        top: 10px;
        color: white;
        font-size: 24px;
      "
    >
      0$
    </div>

    <div
      id="box-text"
      style="
        display: none;
        position: fixed;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        font-size: 20px;
      "
    >
      hehe michael jackson
      <img
        src="https://attic.sh/3v3pgb880x0hjouoi7piydcs4dbt"
        alt="emoji"
        style="width: 50px; height: 50px"
      />
    </div>
    <div id="cash-register">Caisse</div>
<div id="shelf">
  <div class="item" data-price="20">Poop-Sperman</div>
  <div class="item" data-price="20">Cassette Noutendo-DS</div>
</div>
    <div id="interaction-text" class="interaction-text" style="display: none">
      Appuyer sur "E" pour interagir
    </div>
    <ul id="inventory" class="inventory">
      <h2>Mon Inventaire</h2>
      <p>Voici les objets que vous possédez.</p>
      <li>
        <div class="slot1">Vide</div>
      </li>
      <li>
        <div class="slot2">Vide</div>
      </li>
      <li>
        <div class="slot3">Vide</div>
      </li>
      <li>
        <div class="slot4">Vide</div>
      </li>
      <li>
        <div class="slot5">Vide</div>
      </li>
      <li>
        <div class="slot6">Vide</div>
      </li>
      <li>
        <div class="slot7">Vide</div>
      </li>
      <li>
        <div class="slot8">Vide</div>
      </li>
      <li>
        <div class="slot9">Vide</div>
      </li>
      <li>
        <div class="slot10">Vide</div>
      </li>
    </ul>
    <!-- etagere slot -->
    <div class="container">
      <ul
        style="display: none"
        id="shelf-interaction"
        class="shelf-interaction"
      >
        <li>
          <div class="slot0">Vide</div>
        </li>
      </ul>
    </div>

    <!-- - -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.rawgit.com/mrdoob/three.js/r128/examples/js/loaders/GLTFLoader.js"></script>
    <script>
      // Créer la scène
      const scene = new THREE.Scene();

      // Créer la caméra
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 5; // Positionner la caméra

      // Sélectionner l'inventaire

      document.addEventListener("keydown", (event) => {
        if (event.key === "b" || event.key === "B") {
          // Vérifier l'état actuel de l'inventaire et l'afficher ou le masquer
          if (
            inventory.style.display === "none" ||
            inventory.style.display === ""
          ) {
            inventory.style.display = "block"; // Affiche l'inventaire
          } else {
            inventory.style.display = "none"; // Cache l'inventaire
          }
        }
      });

      // Créer le renderer
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Créer une plateforme
      const planeGeometry = new THREE.PlaneGeometry(50, 50);
      const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaa4 });
      const plane = new THREE.Mesh(planeGeometry, planeMaterial);
      plane.rotation.x = -Math.PI / 2; // Rotation pour le mettre à plat
      scene.add(plane);

      // Créer les murs
      const wallHeight = 3; // Hauteur des murs
      const wallThickness = 0.1; // Épaisseur des murs
      const wallMaterial = new THREE.MeshBasicMaterial({ color: 0xf5f5dc }); // Couleur marron

      // Mur avant
      const frontWall = new THREE.Mesh(
        new THREE.BoxGeometry(50, wallHeight, wallThickness),
        wallMaterial
      );
      frontWall.position.set(0, wallHeight / 2, -25); // Positionner le mur avant
      scene.add(frontWall);

      // Mur arrière
      const backWall = new THREE.Mesh(
        new THREE.BoxGeometry(50, wallHeight, wallThickness),
        wallMaterial
      );
      backWall.position.set(0, wallHeight / 2, 25); // Positionner le mur arrière
      scene.add(backWall);

      // Mur gauche
      const leftWall = new THREE.Mesh(
        new THREE.BoxGeometry(wallThickness, wallHeight, 50),
        wallMaterial
      );
      leftWall.position.set(-25, wallHeight / 2, 0); // Positionner le mur gauche
      scene.add(leftWall);

      // Mur droit
      const rightWall = new THREE.Mesh(
        new THREE.BoxGeometry(wallThickness, wallHeight, 50),
        wallMaterial
      );
      rightWall.position.set(25, wallHeight / 2, 0); // Positionner le mur droit
      scene.add(rightWall);

      // Créer le toit
      const roofGeometry = new THREE.BoxGeometry(50, wallThickness, 50); // Largeur, Hauteur, Profondeur
      const roofMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa }); // Couleur rouge foncé
      const roof = new THREE.Mesh(roofGeometry, roofMaterial);
      roof.position.set(0, wallHeight, 0); // Positionner le toit au-dessus des murs
      scene.add(roof);

      function checkCollision(newPosition) {
        const wallDistance = 0.5; // Distance à laquelle le joueur ne peut pas entrer en collision avec les murs

        // Vérifier les collisions avec les murs avant et arrière
        if (
          newPosition.z < -25 + wallDistance ||
          newPosition.z > 25 - wallDistance
        ) {
          return true; // Collision avec le mur avant ou arrière
        }

        // Vérifier les collisions avec les murs gauche et droit
        if (
          newPosition.x < -25 + wallDistance ||
          newPosition.x > 25 - wallDistance
        ) {
          return true; // Collision avec le mur gauche ou droit
        }

        return false; // Pas de collision
      }

      function checkShelfCollision(newPosition) {
        const shelfDistance = 2; // Distance à laquelle le joueur ne peut pas entrer en collision avec l'étagère

        // Vérifier la collision avec l'étagère
        if (
          newPosition.z < shelf.position.z + shelfDistance &&
          newPosition.z > shelf.position.z - shelfDistance &&
          newPosition.x < shelf.position.x + shelfDistance &&
          newPosition.x > shelf.position.x - shelfDistance
        ) {
          return true; // Collision avec l'étagère
        }

        return false; // Pas de collision
      }

const maxPNJ = 5;
let money = 0;

const player = {
  x: window.innerWidth / 2,
  y: window.innerHeight - 150
};

const cashRegister = {
  x: window.innerWidth / 2 - 60, // caisse centrée et largeur 120px
  y: window.innerHeight - 150,
  width: 120,
  height: 100
};

const shelf = {
  x: 20,
  y: window.innerHeight / 2 - 150,
  width: 100,
  height: 300
};

// Création PNJ
const pnjs = [];

function createPNJ(id) {
  const el = document.createElement('div');
  el.classList.add('pnj');
  el.textContent = id + 1;
  document.body.appendChild(el);

  return {
    id,
    el,
    x: shelf.x + shelf.width + 10, // position initiale proche de l'étagère
    y: shelf.y + id * 65,
    target: null,
    carryingItem: null,
    state: 'idle', // idle, goingToShelf, goingToCash, cashing
    timer: 0,
  };
}

for(let i = 0; i < maxPNJ; i++) {
  pnjs.push(createPNJ(i));
}

// Mise à jour position PNJ à l'écran
function updatePNJPosition(pnj) {
  pnj.el.style.left = `${pnj.x}px`;
  pnj.el.style.top = `${pnj.y}px`;
}

// Calcul distance 2D
function dist(x1, y1, x2, y2) {
  return Math.hypot(x2 - x1, y2 - y1);
}

// PNJ se déplace vers un point avec vitesse fixe
function moveTowards(pnj, targetX, targetY, speed = 2) {
  const dx = targetX - pnj.x;
  const dy = targetY - pnj.y;
  const distance = Math.hypot(dx, dy);
  if(distance < speed) {
    pnj.x = targetX;
    pnj.y = targetY;
    return true; // Arrivé
  } else {
    pnj.x += (dx / distance) * speed;
    pnj.y += (dy / distance) * speed;
    return false; // Pas encore arrivé
  }
}

// Récupérer le premier item disponible dans l'étagère
function getFirstShelfItem() {
  const shelfEl = document.getElementById('shelf');
  const items = shelfEl.querySelectorAll('.item');
  if(items.length === 0) return null;
  return items[0];
}

// Supprimer item de l'étagère
function removeShelfItem(itemEl) {
  itemEl.remove();
}

// Vérifie si joueur est proche d'une position
function isPlayerNear(x, y, distance = 80) {
  return dist(player.x, player.y, x, y) <= distance;
}

// Mise à jour affichage argent
function updateMoneyDisplay() {
  document.getElementById('money').textContent = money + '$';
}

// Animation boucle
function animate() {
  pnjs.forEach(pnj => {
    switch(pnj.state) {
      case 'idle':
        // S'il n'a rien, regarde si y'a item dans étagère
        if(!pnj.carryingItem) {
          const item = getFirstShelfItem();
          if(item) {
            pnj.target = {
              type: 'shelf',
              el: item,
              x: shelf.x + shelf.width / 2,
              y: shelf.y + 20 // approximatif
            };
            pnj.state = 'goingToShelf';
          }
        }
        break;

      case 'goingToShelf':
        if(moveTowards(pnj, pnj.target.x, pnj.target.y)) {
          // Arrivé à l'étagère
          if(pnj.target.el) {
            pnj.carryingItem = {
              name: pnj.target.el.textContent,
              price: parseInt(pnj.target.el.dataset.price) || 20
            };
            removeShelfItem(pnj.target.el);
            pnj.target = {
              type: 'cash',
              x: cashRegister.x + cashRegister.width / 2,
              y: cashRegister.y + cashRegister.height / 2
            };
            pnj.state = 'goingToCash';
          } else {
            pnj.state = 'idle';
          }
        }
        break;

      case 'goingToCash':
        if(moveTowards(pnj, pnj.target.x, pnj.target.y)) {
          // Arrivé à la caisse
          pnj.state = 'cashing';
          pnj.timer = 0;
        }
        break;

      case 'cashing':
        pnj.timer += 1/60; // compte le temps en secondes (60 FPS)

        if(pnj.timer >= 3) { // 3 secondes d'encaissement
          // Vérifier si joueur proche de la caisse
          if(isPlayerNear(cashRegister.x + cashRegister.width/2, cashRegister.y + cashRegister.height/2)) {
            money += pnj.carryingItem.price;
            updateMoneyDisplay();
            alert(`PNJ ${pnj.id + 1} a encaisse ${pnj.carryingItem.price}$`);
          }
          pnj.carryingItem = null;
          pnj.state = 'idle';
          pnj.timer = 0;
          pnj.target = null;
        }
        break;
    }

    updatePNJPosition(pnj);
  });










      

      // Créer le joueur
      const playerGeometry = new THREE.BoxGeometry(0.5, 1, 0.5);
      const playerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      const player = new THREE.Mesh(playerGeometry, playerMaterial);
      scene.add(player);
      player.position.y = 0.5; // Positionnez le joueur au-dessus du sol

      // Créer le pnj
      const pnjGeometry = new THREE.BoxGeometry(0.5, 1, 0.5);
      const pnjMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Couleur rouge
      const pnj = new THREE.Mesh(pnjGeometry, pnjMaterial);
      scene.add(pnj);
      pnj.position.set(4, 0.5, 1); // Déplacement à gauche

      //etagere
      let shelf; // Déclaration de la variable shelf

      const loader = new THREE.GLTFLoader();
      loader.load(
        "./models/shelf.gltf",
        (gltf) => {
          shelf = gltf.scene; // Initialisation de shelf ici
          shelf.position.set(0, 0, 10); // Positionnez l'étagère
          scene.add(shelf);
        },
        undefined,
        (error) => {
          console.error(error);
        }
      );
      camera.position.set(0, 1.5, 0); // Position de la caméra à la hauteur des yeux du joueur

      const baseSpeed = 0.1; // Vitesse de base
      let speed = baseSpeed; // Vitesse actuelle
      const keys = {};
      let cameraRotationY = 0; // Angle de rotation de la caméra

      // Écouter les événements de clavier
      window.addEventListener("keydown", (event) => {
        keys[event.key] = true; // Marquer la touche comme enfoncée
        if (event.key === "Shift") {
          speed = baseSpeed * 2; // Doubler la vitesse si Shift est enfoncé
        }
      });

      window.addEventListener("keyup", (event) => {
        keys[event.key] = false; // Marquer la touche comme relâchée
        if (event.key === "Shift") {
          speed = baseSpeed; // Réinitialiser la vitesse à la vitesse de base
        }
      });
      function movePlayer() {
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        direction.y = 0; // Ignorer la composante Y pour le mouvement horizontal
        direction.normalize();

        const right = new THREE.Vector3();
        right.crossVectors(direction, new THREE.Vector3(0, 1, 0)); // Direction droite

        // Calculer la nouvelle position du joueur
        const newPosition = player.position.clone();

        // Déplacement du joueur
        if (keys["z"]) {
          // Avancer
          newPosition.addScaledVector(direction, speed);
          if (checkCollision(newPosition) || checkShelfCollision(newPosition)) {
            newPosition.z = Math.max(newPosition.z, -25 + 0.5); // Ajuster la position si collision
          }
        }
        if (keys["s"]) {
          // Reculer
          newPosition.addScaledVector(direction, -speed);
          if (checkCollision(newPosition) || checkShelfCollision(newPosition)) {
            newPosition.z = Math.min(newPosition.z, 25 - 0.5); // Ajuster la position si collision
          }
        }
        if (keys["q"]) {
          // Tourner à gauche
          camera.rotation.y += 0.05; // Tourner la caméra à gauche
        }
        if (keys["d"]) {
          // Tourner à droite
          camera.rotation.y -= 0.05; // Tourner la caméra à droite
        }

        // Mettre à jour la direction du joueur en fonction de la rotation de la caméra
        direction.set(0, 0, -1); // Direction par défaut vers l'avant
        direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y); // Appliquer la rotation de la caméra
        direction.normalize();

        // Mettre à jour la position du joueur après avoir appliqué la direction
        if (keys["z"]) {
          newPosition.addScaledVector(direction, speed);
        }
        if (keys["s"]) {
          newPosition.addScaledVector(direction, -speed);
        }

        // Vérifier les collisions avec les murs et l'étagère
        if (!checkCollision(newPosition) && !checkShelfCollision(newPosition)) {
          player.position.copy(newPosition); // Mettre à jour la position du joueur seulement s'il n'y a pas de collision
        }

        // Mettre à jour la position de la caméra pour suivre le joueur
        camera.position.x = player.position.x;
        camera.position.z = player.position.z;
      }
      // Appeler la fonction de mouvement à chaque frame
      function animate() {
        requestAnimationFrame(animate);
        movePlayer();
        renderer.render(scene, camera);
      }

      // Fonction pour calculer la distance entre deux objets
      function calculateDistance(obj1, obj2) {
        const dx = obj1.position.x - obj2.position.x;
        const dz = obj1.position.z - obj2.position.z;
        return Math.sqrt(dx * dx + dz * dz);
      }

      const interactionText = document.getElementById("interaction-text");
      const boxText = document.getElementById("box-text");
      const interactionDistance = 2.75; // Distance pour interagir

      // Modifiez la fonction checkInteraction pour inclure l'étagère
      function checkInteraction() {
        const distanceToPnj = calculateDistance(player, pnj);
        const distanceToShelf = calculateDistance(player, shelf);

        if (distanceToPnj <= interactionDistance) {
          interactionText.style.display = "block"; // Montre le texte pour le PNJ
        } else {
          interactionText.style.display = "none"; // Masque le texte pour le PNJ
          boxText.style.display = "none"; // Masque le message pour le PNJ
        }

        if (distanceToShelf <= interactionDistance) {
          interactionText.style.display = "block"; // Montre le texte pour l'étagère
        } else {
          interactionText.style.display = "none"; // Masque le texte pour l'étagère
          document.getElementById("shelf-interaction").style.display = "none"; // Masque le tableau
          document.getElementById("inventory").style.display = "none"; // Masque l'inventaire si le joueur s'éloigne
        }
      }

      // Ajoutez un événement pour afficher le tableau lorsque "E" est pressé
      window.addEventListener("keydown", (event) => {
        if (event.key === "e") {
          const distanceToPnj = calculateDistance(player, pnj);
          const distanceToShelf = calculateDistance(player, shelf);

          if (distanceToPnj <= interactionDistance) {
            boxText.style.display = "block"; // Affiche le message pour le PNJ
          }

          if (distanceToShelf <= interactionDistance) {
            document.getElementById("shelf-interaction").style.display =
              "block"; // Affiche le tableau
          }
        }
      });

      // Exemple d'ajout d'un élément à l'inventaire
      function addItemToInventory(itemName) {
        const inventorySlots = document.querySelectorAll("#inventory div");
        for (let slot of inventorySlots) {
          if (slot.textContent === "Vide") {
            slot.textContent = itemName; // Remplace "Vide" par le nom de l'élément
            break; // Sortir de la boucle après avoir ajouté l'élément
          }
        }
      }

      // Exemple d'interaction avec l'étagère pour ajouter un élément
      window.addEventListener("keydown", (event) => {
        if (event.key === "e") {
          const distanceToShelf = calculateDistance(player, shelf);
          if (distanceToShelf <= interactionDistance) {
            document.getElementById("shelf-interaction").style.display =
              "block"; // Affiche le tableau
          }
        }
      });

      // Ajoutez cette fonction pour afficher l'inventaire à gauche
      function showInventory() {
        document.getElementById("inventory").style.display = "block"; // Affiche l'inventaire
      }

      // Modifiez l'événement de la touche "e" pour afficher l'inventaire
      window.addEventListener("keydown", (event) => {
        if (event.key === "e") {
          const distanceToShelf = calculateDistance(player, shelf);
          if (distanceToShelf <= interactionDistance) {
            showInventory(); // Affiche l'inventaire
          }
        }
      });

      // Ajoutez un événement de clic sur les éléments de l'inventaire
      document.querySelectorAll("#inventory div").forEach((slot) => {
        slot.addEventListener("click", () => {
          if (slot.textContent !== "Vide") {
            addItemToSlot1(slot.textContent); // Ajoute l'élément au slot 1
            slot.textContent = "Vide"; // Vide le slot après l'ajout
          }
        });
      });

      // Fonction pour ajouter un élément au slot 1
      function addItemToSlot1(itemName) {
        const slot1 = document.querySelector(".slot0");
        slot1.textContent = itemName; // Ajoute l'élément au slot 1
        startSellTimer(itemName); // Démarre le timer de vente
      }

      // Fonction pour démarrer le timer de vente
      function startSellTimer(itemName) {
        setTimeout(() => {
          const slot1 = document.querySelector(".slot0");
          slot1.textContent = "Vide"; // Vide le slot 1 après 30 secondes
          showSaleMessage(); // Affiche le message de vente
        }, 30000); // 30 secondes
      }

      // Fonction pour afficher le message de vente
      function showSaleMessage() {
        const messageBox = document.createElement("div");
        messageBox.style.position = "fixed";
        messageBox.style.left = "50%";
        messageBox.style.top = "50%";
        messageBox.style.transform = "translate(-50%, -50%)";
        messageBox.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
        messageBox.style.color = "white";
        messageBox.style.padding = "20px";
        messageBox.style.borderRadius = "10px";
        messageBox.style.textAlign = "center";
        messageBox.innerText = "Vous avez gagné 20$!";
        document.body.appendChild(messageBox);

        // Supprime le message après quelques secondes
        setTimeout(() => {
          document.body.removeChild(messageBox);
        }, 5000); // Affiche le message pendant 5 secondes
      }

      function animate() {
        console.log("Animating..."); // Pour voir si la fonction est appelée
        requestAnimationFrame(animate);
        movePlayer();
        checkInteraction();

        renderer.render(scene, camera);
      }

      window.addEventListener("keydown", (event) => {
        if (event.key === "a") {
          addItemToInventory("Nouvel Élement");
        }
      });

      //les items
      // Liste des items avec leurs images
      const items = [
        {
          id: 1,
          name: "Poop-Sperman",
          image:
            "https://www.tradeinn.com/f/13840/138406492_2/funko-pop-dc-comics-superman-course-poursuite-aleatoire-exclusive-25-cm.webp",
          slot: null,
        },
        {
          id: 2,
          name: "Cassette de jeu pour la Noutendo-DS avec le jeu Vodkai-Watch",
          image:
            "https://images7.memedroid.com/images/UPLOADED492/6507564cbf03d.jpeg",
          slot: null,
        },
      ];

      // Fonction pour ajouter les items à l'inventaire
      function addItemsToInventory() {
        items.forEach((item) => {
          const inventorySlots = document.querySelectorAll("#inventory div");
          for (let i = 0; i < inventorySlots.length; i++) {
            const slot = inventorySlots[i];
            if (slot.textContent === "Vide") {
              // Vérifier si le slot est vide
              const img = document.createElement("img"); // Créer un élément d'image
              img.src = item.image; // Assigner l'URL de l'image
              img.alt = item.name; // Ajouter un texte alternatif
              img.style.width = "50px"; // Définir la largeur de l'image
              img.style.height = "50px"; // Définir la hauteur de l'image
              slot.textContent = ""; // Vider le texte du slot
              slot.appendChild(img); // Ajouter l'image au slot
              item.slot = i + 1; // Assigner le slot à l'item
              break; // Sortir de la boucle après avoir ajouté l'item
            }
          }
        });
      }

      document.querySelectorAll("#inventory div").forEach((slot) => {
        slot.addEventListener("click", () => {
          const itemId = slot.getAttribute("data-id"); // Récupère l'ID de l'élément à ajouter
          const currentSlotItem = document.querySelector("#slot1"); // Supposons que le slot 1 a l'ID 'slot1'

          if (currentSlotItem.textContent === "Vide") {
            // Si le slot est vide, ajoute l'élément
            addItemToSlot1(slot.textContent); // Ajoute l'élément au slot 1
            currentSlotItem.setAttribute("data-id", itemId); // Définit l'ID de l'élément dans le slot
            slot.textContent = "Vide"; // Vide le slot après l'ajout
          } else {
            const currentSlotId = currentSlotItem.getAttribute("data-id"); // Récupère l'ID de l'élément dans le slot

            if (currentSlotId === itemId) {
              // Si l'ID correspond, incrémente le nombre d'éléments
              incrementItemCount(currentSlotItem); // Fonction à définir pour incrémenter le nombre
            } else {
              alert(
                "Vous ne pouvez pas ajouter un élément avec un ID différent."
              );
            }
          }
        });
      });

      // Fonction pour ajouter un élément à l'étagère
      function addItemToShelf(itemId) {
        const shelfSlot = document.querySelector(".slot0"); // Supposons que la slot0 est celle de l'étagère

        if (shelfSlot.textContent === "Vide") {
          // Si le slot est vide, ajoute l'élément
          shelfSlot.textContent = itemId; // Ajoute l'ID de l'élément
        } else {
          const currentSlotId = shelfSlot.textContent; // Récupère l'ID de l'élément dans le slot

          if (currentSlotId === itemId) {
            // Si l'ID correspond, incrémente le nombre d'éléments
            incrementItemCount(shelfSlot); // Fonction pour incrémenter le nombre
          } else {
            // Si l'ID ne correspond pas, afficher un message et ne rien faire
            alert(
              "Vous ne pouvez pas ajouter un élément avec un ID différent."
            );
            return; // Sortir de la fonction pour éviter d'ajouter l'élément
          }
        }
      }

      // Fonction pour incrémenter le nombre d'éléments dans le slot
      function incrementItemCount(slot) {
        let count = parseInt(slot.textContent) || 0; // Récupère le nombre actuel ou 0
        count += 1; // Incrémente le nombre
        slot.textContent = count.toString(); // Met à jour le texte du slot
      }

      // Écouteur d'événements pour ajouter un élément à l'étagère
      document.querySelectorAll("#inventory div").forEach((slot) => {
        slot.addEventListener("click", () => {
          const itemId = slot.getAttribute("data-id"); // Récupère l'ID de l'élément à ajouter
          const shelfSlot = document.querySelector(".slot0"); // Récupère le slot de l'étagère

          // Vérifiez si le slot de l'étagère est vide ou si l'ID correspond
          if (shelfSlot.textContent === "Vide") {
            addItemToShelf(itemId); // Appelle la fonction pour ajouter à l'étagère
            slot.textContent = "Vide"; // Vide le slot de l'inventaire après l'ajout
          } else {
            const currentSlotId = shelfSlot.textContent; // Récupère l'ID de l'élément dans le slot
            if (currentSlotId === itemId) {
              addItemToShelf(itemId); // Appelle la fonction pour ajouter à l'étagère
              slot.textContent = "Vide"; // Vide le slot de l'inventaire après l'ajout
            } else {
              alert(
                "Vous ne pouvez pas ajouter un élément avec un ID différent."
              );
            }
          }
        });
      });
      addItemsToInventory();

      function updateMoneyDisplay() {
        document.getElementById("money").textContent = money + "$"; // Met à jour le texte de la div
      }

      // Modifiez la fonction showSaleMessage pour ajouter de l'argent
      function showSaleMessage() {
        const messageBox = document.createElement("div");
        messageBox.style.position = "fixed";
        messageBox.style.left = "50%";
        messageBox.style.top = "50%";
        messageBox.style.transform = "translate(-50%, -50%)";
        messageBox.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
        messageBox.style.color = "white";
        messageBox.style.padding = "20px";
        messageBox.style.borderRadius = "10px";
        messageBox.style.textAlign = "center";
        messageBox.innerText = "Vous avez gagné 20$!";

        // Ajoutez l'argent à la variable money
        money += 20; // Ajoutez le prix de l'item vendu
        updateMoneyDisplay(); // Mettez à jour l'affichage de l'argent

        document.body.appendChild(messageBox);

        // Supprime le message après quelques secondes
        setTimeout(() => {
          document.body.removeChild(messageBox);
        }, 5000); // Affiche le message pendant 5 secondes
      }

      let money = 0; // Variable pour stocker l'argent

      // Fonction pour mettre à jour l'affichage de l'argent
      function updateMoneyDisplay() {
        document.getElementById("money").textContent = money + "$"; // Met à jour le texte de la div
      }

      animate();
    </script>
  </body>
</html>

